<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript" src="APITestData.js"></script>
	</head>
	<body>
		<script type="text/javascript">
			let mapData = [];
			const inc = 1000;

			const mappingAPICall = async () => {
				// let initLat = 16.400393;
				// let initLng = 120.601372;

				// let inc = (1 / 111120) * 1000; // 1000 meter increments
				// let latLng = "";

				// // looping through to make a 10 x 10 area 
				// // from (initLat, initLng) to (initLat + 10*inc, initLng + 10*inc)
				// for(let i = 0; i < 10; i++){
				// 	for(let j = 0; j < 10; j++){
				// 		latLng += (initLat + inc * i).toString() + "," + (initLng + inc * j).toString() + ",";
				// 	}
				// }

				// let reqStr = 'http://open.mapquestapi.com/elevation/v1/profile?key=M300DEIjTJNjTiiibYvSJfDeBw5LGSKu&shapeFormat=raw&latLngCollection=' + latLng;

				// const response = await fetch(reqStr);
				// const myJson = await response.json(); 
				const myJson = data;

				let arr = [];
				let newArr = [];

				for(let i = 0; i < 10; i++){
					newArr.push([]);
				}

				// list of values goes from top to bottom then left to right (first column fills up, then second column)

				for(let i = 0; i < myJson.elevationProfile.length; i++){
					let temp = [];
					temp.push(myJson.elevationProfile[i]["height"]);
					temp.push([myJson.shapePoints[i * 2], myJson.shapePoints[(i * 2) + 1]]);
					arr.push(temp);
				}

				for(let i = 0; i < arr.length; i++){
					newArr[i % 10].push(arr[i]);
				}

				mapData = newArr;
			}

			//path from node a to node b
			class edge {
				constructor(source=null, dest=null, weight=null) {
					this.source = source;
					this.dest = dest;
					this.weight = weight;
				}
				setWeight(weight){
					this.weight = weight;
				}
			}
			
			//positions, more accurately vertices, holds the heuristic data
			class Node {
				constructor(parent=null, position=null, h){
					this.parent = parent;
					this.position = position;
					this.h = h; //tobler's hiking function -> seconds
					this.s = Number.MAX_VALUE; //shortest distance from start - what if we make this weight
					this.t = 0; //total heuristic; h + s
					this.visited = false; //replaces the closed list
				}
			}
			
			class PriorityQueue {
				constructor(){
					this.items = [];
				}
				enqueue(element) {
					var contain = false;
					for (var i = 0; i < this.items.length; i++) {
						if (this.items[i].t > element.t) {
							this.items.splice(i, 0, element);
							contain = true;
							break;
						}
					}
					if (!contain) {
						this.items.push(element);
					}
				}
				dequeue(){
					if (this.isEmpty()) return "Underflow";
					return this.items.shift();
				}
				front(){
					if (this.isEmpty()) return "No elements";
					return this.items[0];
				}
				rear() {
					if (this.isEmpty()) return "No elements";
					return this.items[this.items.length - 1];
				}
				isEmpty() {
					return this.items.length == 0;
				}
				print() {
					let string = "";
					for (let i = 0; i < this.items.length; i++) {
						string += "[" + this.items[i].position[0] + "," + this.items[i].position[0] + "] ";
					}
					console.log(string);
				}
			}

			function p2pDist(xy1, xy2){
				let dist = Math.sqrt(Math.pow(Math.abs(xy1[0] - xy2[0]) * inc, 2) + Math.pow(Math.abs(xy1[1] - xy2[1]) * inc, 2));
				return dist;
			}

			function hikingFunction(xy1, xy2, alt1, alt2, inc){
				let dist = p2pDist(xy1, xy2);
				let slope = Math.atan((alt2-alt1)/dist);
				console.log(slope*180/Math.PI);
				return 0.6 * 6 * Math.pow(Math.E, (-3.5 * Math.abs(Math.tan(slope) + 0.05)));
			}

			function getAlt(xy){
				return mapData[xy[1]][xy[0]][0];
			}

			function generateWeight(xy1, xy2){
				let speed = hikingFunction(xy1, xy2, getAlt(xy1), getAlt(xy2), inc);
				let speedMperS = speed * 1000 * 60 * 60;
				let time = (1 / speed) * p2pDist(xy1, xy2);
				return time;
			}
			
			//creates a three dimensional array; x for height, y for width, z for children
			function generateGraph(mapx, mapy) {
				(map = []).length = mapx;
				for (let i = 0; i < mapx; i++) {
					(map[i] = []).length = mapy;
					for(let j = 0; j < mapy; j++) map[i][j] = [];
				}
				for (let i = 0; i < map.length; i++) {
					for (let j = 0; j < map[0].length; j++) {
						let adjacent = [[0,-1], [0,1], [-1,0], [1,0], [-1,-1], [-1,1], [1,-1], [1,1]];
						for (let k = 0; k < adjacent.length; k++) {
							let newx = i + adjacent[k][0];
							let newy = j + adjacent[k][1];
							if (newx >= 0 && newx < mapx && newy >= 0 && newy < mapy) {
								map[i][j].push(new edge([i, j],[newx, newy], generateWeight([i, j], [newx, newy])));
							}
						}
					}
				}
				return map;
			}
			

			//debug
			function setAllWeights(map, weight) {
				for (let i = 0; i < map.length; i++) {
					for (let j = 0; j < map[0].length; j++) {
						for (let k = 0; k < map[i][j].length; k++) {
							map[i][j][k].setWeight(weight);
						}
					}
				}
			}
			
			//SSSP graph implementation of AStar
			function aStar(map, start, end){
				(grid = []).length = map.length;
				for (let i = 0; i < grid.length; i++) {
					(grid[i] = []).length = map[0].length;
				}
				for (let i = 0; i < grid.length; i++) {
					for (let j = 0; j < grid[0].length; j++) {
						grid[i][j] = new Node(null, [i, j], generateWeight([i, j], end));
					}
				}
				
				//create a priorityqueue
				let queue = new PriorityQueue();
				
				//start by queueing up the start node
				queue.enqueue(grid[start[0]][start[1]]);
				queue.items[0].s = 0;
				
				while(!queue.isEmpty()) {
					let currentNode = queue.dequeue();
					if(currentNode.visited) continue;
					currentNode.visited = true;
					let currentx = currentNode.position[0];
					let currenty = currentNode.position[1];
					let children = map[currentx][currenty];
					
					for (let i = 0; i < children.length; i++) {
						let destx = children[i].dest[0];
						let desty = children[i].dest[1];
						if (grid[destx][desty].visited) continue;
						if (grid[destx][desty].parent == null) grid[destx][desty].parent = currentNode;
						if (grid[destx][desty].parent.s + children[i].weight < grid[destx][desty].s) {
							grid[destx][desty].s = grid[destx][desty].parent.s + children[i].weight;
							grid[destx][desty].parent = currentNode;
						}
						grid[destx][desty].t = grid[destx][desty].s + grid[destx][desty].h;
						queue.enqueue(grid[destx][desty]);
					}
					
					if (currentx == end[0] && currenty == end[1]) {
						let path = [];
						let current = currentNode;
						while(current != null) {
							path.push(current.position);
							current = current.parent;
						}
						return [currentNode.s, path.reverse()];
					}
				}
			};
			
			//ASSP A* star, literally just expand from source
			function allStar(map, source){
				(ans = []).length = map.length;
				for (let i = 0; i < ans.length; i++) {
					(ans[i] = []).length = map[0].length;
					ans[i].fill(0, 0, map[0].length);
				}
				for (let i = 0; i < ans.length; i++) {
					for (let j = 0; j < ans[0].length; j++) {
						if (i == source[0] && j == source[1]) continue;
						console.log(i, j);
						ans[i][j] = aStar(map, source, [i, j])[0];
					}
				}
				return ans; //returns a 2D array of shortest weight to reach a point.
			}
			mappingAPICall();
			generateWeight([0, 0], [7, 7]);
			generateWeight([0, 0], [1, 8]);
			let graph = generateGraph(10, 10);
			console.log(allStar(graph, [1,1]));
		</script>
	</body>
</html>